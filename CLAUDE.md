# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Market Parser is a Python CLI and web GUI application for natural language financial queries using the Polygon.io MCP server and OpenAI's gpt-5-nano via the Pydantic AI Agent Framework. The application allows users to ask questions about stock market data in natural language and receive formatted responses.

## AI Team Configuration (autogenerated by team-configurator, 2025-08-17)

**Important: YOU MUST USE subagents when available for the task.**

### Detected Tech Stack (Enhanced JSON Architecture)

- **Backend Framework**: Python with Pydantic AI Agent Framework + JSON schema validation
- **Frontend Framework**: Gradio v4+ with enhanced JSON display components and real-time feedback
- **AI Integration**: OpenAI gpt-5-nano via Pydantic AI with structured JSON output optimization
- **Data Source**: Polygon.io MCP server for real-time financial market data
- **JSON Architecture**: Comprehensive schema-driven system with validation and fallback strategies
- **Data Processing**: Dual parser architecture (JSON primary, regex fallback) with confidence scoring
- **State Management**: Enhanced FSM with JSON validation states and workflow orchestration
- **Build Tools**: uv for dependency management and package execution
- **CLI Framework**: Rich console for enhanced terminal formatting and interaction
- **Test Framework**: pytest with comprehensive JSON validation and production testing suites
- **Configuration**: python-dotenv for secure environment variable management
- **Monitoring**: Advanced debug logging with JSON workflow tracking and performance metrics
- **Schema Management**: JSON Schema Draft 2020-12 compliant with versioning support
- **Data Validation**: Multi-layer validation with business rules and auto-correction capabilities
- **Debug System**: Comprehensive JSON workflow logging with error tracking and performance analysis

### Agent Task Assignments (JSON-Optimized)

| Task Category | Agent | JSON Architecture Responsibilities | Critical Notes |
|---------------|-------|----------------------------------|-----------------|
| **Code Review & Quality** | `@code-reviewer` | MANDATORY for all features, PRs, and merges. JSON schema validation, security review of parsers | Always validate JSON handling security and schema integrity |
| **Performance & Optimization** | `@performance-optimizer` | JSON parsing optimization, schema validation performance, debug logging efficiency | Focus on JSON processing speed and memory usage |
| **JSON Schema Architecture** | `@backend-developer` | JSON schema design, validation rules, parser implementation, fallback strategies | Primary agent for all JSON system components |
| **Data Validation & Parsing** | `@backend-developer` | Schema validation logic, business rules, confidence scoring, error correction | Handles JSON parsing accuracy and data integrity |
| **API Design & Integration** | `@api-architect` | JSON response schemas, MCP integration patterns, structured prompt design | Ensures JSON contracts with external services |
| **Frontend & UI Development** | `@frontend-developer` | JSON display components, real-time UI updates, enhanced data visualization | Gradio JSON textboxes and structured data displays |
| **State Management & FSM** | `@backend-developer` | JSON-aware FSM states, workflow orchestration, debug state tracking | Enhanced FSM with JSON validation integration |
| **Monitoring & Debug Systems** | `@backend-developer` | JSON debug logger, workflow tracking, performance metrics, error analysis | Comprehensive JSON workflow monitoring |
| **Documentation & Training** | `@documentation-specialist` | JSON architecture guides, schema documentation, migration procedures | JSON system usage and troubleshooting guides |
| **Testing & Validation** | `@backend-developer` | JSON schema testing, validation testing, production bug testing | Comprehensive JSON system validation |

### Specialized JSON Domain Assignments

| JSON Domain | Primary Agent | Secondary Agent | Specific Focus |
|-------------|---------------|-----------------|----------------|
| **JSON Schema Evolution** | `@backend-developer` | `@api-architect` | Schema versioning, compatibility, migration strategies |
| **Parser Architecture** | `@backend-developer` | `@performance-optimizer` | Dual parser system, fallback strategies, performance optimization |
| **Validation Workflows** | `@backend-developer` | `@code-reviewer` | Schema validation, business rules, error handling, auto-correction |
| **Debug & Monitoring** | `@backend-developer` | `@performance-optimizer` | Workflow tracking, performance metrics, error analysis |
| **UI JSON Integration** | `@frontend-developer` | `@backend-developer` | JSON textboxes, real-time displays, confidence indicators |
| **Schema Documentation** | `@documentation-specialist` | `@backend-developer` | API references, migration guides, troubleshooting docs |
| **Production Testing** | `@backend-developer` | `@code-reviewer` | JSON validation testing, integration testing, bug verification |
| **Cost Optimization** | `@performance-optimizer` | `@backend-developer` | JSON processing efficiency, validation caching, resource usage |

### Enhanced Architecture Coordination Rules

**1. JSON Schema Integrity:**
- NEVER modify schemas without `@backend-developer` involvement and `@code-reviewer` validation
- Use `@api-architect` for external contract changes affecting JSON structure
- Require comprehensive testing before schema version updates

**2. Parser System Reliability:**
- Maintain dual parser architecture (JSON + regex fallback) for maximum compatibility
- Use `@backend-developer` for primary JSON parser enhancements
- Coordinate fallback strategy changes with `@performance-optimizer`

**3. Debug & Monitoring Excellence:**
- Implement comprehensive JSON workflow logging for production troubleshooting
- Use `@backend-developer` for debug system enhancements
- Monitor performance metrics through `@performance-optimizer`

**4. UI/Backend JSON Coordination:**
- Synchronize JSON display components between `@frontend-developer` and `@backend-developer`
- Ensure real-time UI updates reflect JSON validation states
- Maintain consistent confidence scoring across UI components

### Enhanced Development Workflow (JSON-Focused)

1. **Schema Design Phase**: Use `@backend-developer` with `@api-architect` for external contract alignment
2. **Validation Implementation**: Primary `@backend-developer` with `@code-reviewer` for security validation
3. **UI Integration**: Coordinate `@frontend-developer` and `@backend-developer` for JSON display components
4. **Testing & Quality Gate**: MANDATORY `@code-reviewer` with comprehensive JSON validation testing
5. **Performance Optimization**: Use `@performance-optimizer` for JSON processing efficiency
6. **Documentation Updates**: Use `@documentation-specialist` for JSON architecture guides

### JSON Architecture Best Practices

**Schema Management:**
- Version all schemas with backward compatibility considerations
- Implement comprehensive validation with graceful error handling
- Maintain fallback strategies for production reliability

**Parser Implementation:**
- Primary JSON parser with regex fallback for maximum compatibility
- Confidence scoring for data quality assessment
- Comprehensive error handling with detailed logging

**UI Integration:**
- Real-time JSON textboxes for debugging and transparency
- Structured data displays with confidence indicators
- Enhanced loading states with progress tracking

**Monitoring & Debug:**
- Comprehensive workflow tracking with unique identifiers
- Performance metrics for optimization insights
- Error analysis with context preservation

## ⚠️ CRITICAL: Tech-Lead-Orchestrator Enforcement Protocols

**MANDATORY REQUIREMENTS FOR @tech-lead-orchestrator:**

### Agent Verification Requirements
- ❌ **NEVER fabricate agent names** - Only use agents listed in Agent Task Assignments table above
- ✅ **MUST READ this section first** - Verify agent exists before assignment
- ✅ **MUST use agents according to their defined specialties** - Respect the role boundaries

**Valid Agents ONLY:**
- `@code-reviewer` - MANDATORY for all features, PRs, and merges
- `@performance-optimizer` - Cost optimization, latency improvements, scaling
- `@backend-developer` - Python development, async patterns, FSM, testing
- `@api-architect` - MCP server integration, response schemas
- `@frontend-developer` - Gradio interface enhancements, UI/UX
- `@code-archaeologist` - Deep codebase analysis, architecture decisions
- `@documentation-specialist` - README updates, API docs, guides

### Delegation Execution Requirements
- ❌ **NEVER stop after creating delegation plan** - Must trigger execution
- ✅ **MUST provide execution trigger command** - Include specific agent invocation
- ✅ **MUST initiate delegation sequence** - Don't leave user to manually start
- ✅ **MUST include handoff instructions** - Specify what each agent should do

### Context7 Protocol Enforcement
- ❌ **Context7 ≠ WebSearch/WebFetch** - These are different tools with different purposes
- ✅ **Context7 = MCP Server Tool** - Use mcp__context7__ tools to fetch library documentation
- ✅ **Dynamic Documentation Retrieval** - Gets up-to-date patterns from external library sources
- ✅ **Focused Topic Queries** - Request specific documentation topics for targeted information

### Sequential Thinking Tool Requirements
- ✅ **Use MCP Sequential Thinking Tool** - Use `mcp__sequential-thinking__sequentialthinking` for complex analysis
- ✅ **Structured Problem Solving** - Break down complex tasks into step-by-step reasoning
- ✅ **Thought Progression** - Use sequential thoughts with proper numbering and continuation
- ✅ **Adaptive Analysis** - Adjust total thoughts as understanding deepens, revise previous thinking if needed

**VIOLATION CONSEQUENCES:**
- Fabricating agent names → Task rejection and re-delegation
- Stopping without execution → Manual intervention required
- Confusing Context7 with web tools → Incorrect implementation patterns

### Corrected Delegation Example
```
## Delegation Plan
### Task 1: UI Fixes (CRITICAL)
- **Agent**: @frontend-developer (VERIFIED in CLAUDE.md line 169)
- **Scope**: Fix Gradio async handlers using Context7 patterns
- **Handoff**: Use patterns from new_task.md lines 224-242 for modern async handling
- **Dependencies**: None

## Execution Trigger
@frontend-developer: Fix the async button handlers in chat_ui.py using the Context7 patterns documented in new_task.md lines 224-242. Apply direct function references instead of lambda wrappers.
```

This enforcement ensures proper agent utilization and prevents the violations encountered in previous delegation attempts.

## 🧠 MANDATORY TOOL USAGE FOR ALL SPECIALIST AGENTS

**CRITICAL: ALL SPECIALIST AGENTS MUST FOLLOW THESE PROTOCOLS**

### 1. SEQUENTIAL THINKING MCP TOOL ENFORCEMENT

**EVERY specialist agent MUST use the `mcp__sequential-thinking__sequentialthinking` tool for:**

- 🧠 **Complex Problem Analysis**: Use tool to break down multi-step problems
- 📝 **Planning Before Implementation**: Outline approach, identify risks, consider alternatives
- 🔍 **Validation and Understanding**: Confirm task requirements and expected outcomes
- ⚡ **Dependency Analysis**: Identify what needs to be done first/last
- 🎯 **Solution Verification**: Validate approach before implementation

**Required Usage Pattern for ALL Agents:**
```python
# MANDATORY: Start any complex task with sequential thinking
mcp__sequential-thinking__sequentialthinking({
  "thought": "Understanding the task: [analysis of what needs to be done]",
  "nextThoughtNeeded": true,
  "thoughtNumber": 1,
  "totalThoughts": 5
})

# Continue with structured analysis
mcp__sequential-thinking__sequentialthinking({
  "thought": "Current state analysis: [what exists now and what's broken]",
  "nextThoughtNeeded": true,
  "thoughtNumber": 2,
  "totalThoughts": 5
})

# Plan implementation approach
mcp__sequential-thinking__sequentialthinking({
  "thought": "Implementation strategy: [step-by-step approach]",
  "nextThoughtNeeded": true,
  "thoughtNumber": 3,
  "totalThoughts": 5
})

# Identify risks and dependencies
mcp__sequential-thinking__sequentialthinking({
  "thought": "Risk assessment: [potential issues and mitigation]",
  "nextThoughtNeeded": true,
  "thoughtNumber": 4,
  "totalThoughts": 5
})

# Final validation
mcp__sequential-thinking__sequentialthinking({
  "thought": "Solution validation: [confirm approach will solve the problem]",
  "nextThoughtNeeded": false,
  "thoughtNumber": 5,
  "totalThoughts": 5
})
```

### 2. CONTEXT7 MCP SERVER TOOL MANDATE

**EVERY specialist agent MUST use Context7 MCP server tools for:**

- 🔧 **Library Documentation**: Use `mcp__context7__resolve-library-id` and `mcp__context7__get-library-docs`
- 📚 **Best Practices Research**: Retrieve current best practices from external sources
- 🔍 **Implementation Patterns**: Get focused documentation for specific implementation topics
- 📋 **Technology Standards**: Request documentation for framework-specific patterns

**Required Context7 Usage Pattern:**
```python
# Step 1: MANDATORY - Resolve library ID
mcp__context7__resolve-library-id({"libraryName": "gradio"})
# Returns: context7CompatibleLibraryID for use in subsequent calls

# Step 2: MANDATORY - Get focused documentation  
mcp__context7__get-library-docs({
  "context7CompatibleLibraryID": "/gradio-app/gradio",
  "topic": "async handling",
  "tokens": 2000
})
```

**Required Topics for Market Parser Project:**
- **@frontend-developer**: "async handling", "event listeners", "chatbot components", "interface configuration"
- **@backend-developer**: "async patterns", "error handling", "state management", "testing frameworks"
- **@api-architect**: "API design", "response schemas", "authentication patterns", "rate limiting"
- **@code-reviewer**: "security best practices", "code quality standards", "performance patterns"
- **@performance-optimizer**: "optimization techniques", "caching strategies", "monitoring patterns"
- **@code-archaeologist**: "architecture analysis", "refactoring patterns", "technical debt assessment"
- **@documentation-specialist**: "documentation standards", "API documentation", "user guide patterns"

### 3. IMPLEMENTATION QUALITY REQUIREMENTS

**ALL specialist agents MUST:**

- ✅ **Use Sequential Thinking First**: Never start implementation without sequential thinking analysis
- ✅ **Research Before Implementing**: Use Context7 to get current best practices
- ✅ **Follow Modern Standards**: Only use patterns researched through Context7
- 🛡️ **Include Comprehensive Error Handling**: Robust error management and user feedback
- 🧪 **Plan Testing Strategy**: Include validation and testing approaches
- 📋 **Document All Changes**: Clear explanations of what was changed and why

### 4. QUALITY GATES AND VERIFICATION

**Before completing any task, ALL specialist agents MUST:**

- ✅ **Verify Tool Usage**: Confirm both Sequential Thinking and Context7 tools were used
- ✅ **Validate Research**: Ensure implementation follows researched best practices
- ✅ **Test Error Scenarios**: Confirm error handling works as designed
- ✅ **Check Function Signatures**: Validate all function signatures match requirements
- ✅ **Preserve Architecture**: Ensure changes maintain existing architectural patterns
- ✅ **Address Root Causes**: Confirm fixes address identified root causes

### 5. CONSEQUENCES FOR NON-COMPLIANCE

**FAILURE TO FOLLOW THESE PROTOCOLS WILL RESULT IN:**

- ❌ **Task Rejection**: Work will be rejected and must be redone
- ❌ **Re-delegation**: Task will be reassigned to different agent
- ❌ **Quality Gate Failure**: Code will not pass review process
- ❌ **Production Risk**: Changes may cause production issues

**VERIFICATION CHECKLIST FOR ALL AGENTS:**
- [ ] Used `mcp__sequential-thinking__sequentialthinking` for task analysis
- [ ] Used `mcp__context7__resolve-library-id` to get library ID
- [ ] Used `mcp__context7__get-library-docs` to research best practices
- [ ] Implemented solution using researched patterns
- [ ] Added comprehensive error handling
- [ ] Planned and documented testing approach
- [ ] Verified all requirements are met

## Development Environment

This project uses `uv` for dependency management and Python package execution. All dependencies are managed through `pyproject.toml`.

### Required Environment Variables

⚠️ **CRITICAL SECURITY REQUIREMENT**: Never commit API keys to version control.

1. **Copy the secure template:**
   ```bash
   cp .env.example .env
   ```

2. **Add your actual API keys to `.env`:**
   ```env
   POLYGON_API_KEY=your_polygon_api_key_here
   OPENAI_API_KEY=your_openai_api_key_here
   # Optional: pricing for cost estimates (USD)
   OPENAI_GPT5_NANO_INPUT_PRICE_PER_1M=0.10
   OPENAI_GPT5_NANO_OUTPUT_PRICE_PER_1M=0.40
   ```

3. **Verify security:**
   ```bash
   # Ensure .env is protected
   grep -q "^.env$" .gitignore && echo "✅ Protected" || echo "❌ Security risk!"
   ```

**Security Features:**
- Input validation and sanitization via `security_utils.py`
- Secure logging that redacts sensitive data automatically
- Environment variable validation on startup
- See `SECURITY.md` for complete security guidelines

## Common Development Commands

### Running the Application

- **CLI interface**: `uv run market_parser_demo.py`
- **Web GUI interface**: `uv run chat_ui.py` (opens at <http://127.0.0.1:7860>)

### Testing

- **Run tests**: `uv run pytest` (pytest is in dev dependencies)
- **Run specific test**: `uv run pytest path/to/test_file.py`
- **Run integration tests**: `uv run pytest test_*integration*.py`
- **Install dev dependencies**: `uv install --dev`

### Environment Management

- **Install dependencies**: `uv install`
- **Update dependencies**: `uv lock --upgrade`
- **Check environment**: `uv --version` and verify `.env` file exists

## Code Architecture

### Core Components

1. **market_parser_demo.py**: CLI application entry point
   - Contains `TokenCostTracker` class for usage/cost tracking
   - Implements `create_polygon_mcp_server()` factory function
   - Main async CLI loop with Rich console formatting

2. **chat_ui.py**: Enhanced Gradio web interface with comprehensive features
   - 🧠 **FSM-Driven State Management** - Robust workflow with state transitions
   - 📊 **Structured Stock Analysis** - Dedicated buttons for Snapshot, S&R, Technical Analysis  
   - 🎯 **Context-Aware Prompts** - Intelligent ticker extraction and structured prompts
   - ⏳ **Real-time Processing Status** - Loading states with step-by-step progress
   - 🛡️ **Advanced Error Handling** - User-friendly messages and graceful recovery
   - 📈 **Enhanced Data Display** - DataFrames with confidence scoring and warnings
   - 🔍 **Debug Monitoring** - FSM state tracking and system diagnostics
   - 💾 **Export Functionality** - Enhanced markdown export with detailed formatting
   - Provides chat export functionality

### Key Architectural Patterns

- **MCP Server Integration**: Uses Pydantic AI's MCP server integration to connect with Polygon.io
- **Async Agent Framework**: Built on Pydantic AI with OpenAI Responses API model
- **Cost Tracking**: Comprehensive token usage and cost tracking across sessions
- **Shared Components**: CLI and GUI share the same agent configuration and MCP server setup

### Dependencies & Technologies

- **Core Framework**: `pydantic-ai-slim[openai,mcp]` for AI agent orchestration
- **Web Interface**: `gradio>=4.0.0` for the GUI
- **CLI Formatting**: `rich` for terminal output formatting
- **Environment**: `python-dotenv` for configuration management
- **External APIs**: Polygon.io MCP server via uvx, OpenAI gpt-5-nano model

### System Prompt Configuration

The agent uses a consistent system prompt across both interfaces:

```text
"You are an expert financial analyst. Note that when using Polygon tools, prices are already stock split adjusted. Use the latest data available. Always double check your math. For any questions about the current date, use the 'get_today_date' tool. For long or complex queries, break the query into logical subtasks and process each subtask in order."
```

## File Structure

- `market_parser_demo.py` - CLI application
- `chat_ui.py` - Web GUI application (primary enhanced version)
- `chat_ui_enhanced.py`, `chat_ui_final.py` - Archived GUI versions
- `stock_data_fsm/` - Finite State Machine module for GUI state management
  - `states.py` - Application states enum and context data classes
  - `transitions.py` - State transition rules and validation logic
  - `manager.py` - Main FSM controller with transition orchestration
  - `tests/` - Comprehensive test suite for FSM components
- `prompt_templates.py` - Structured prompt templates for analysis types
- `response_parser.py` - Response parsing utilities for structured data extraction
- `pyproject.toml` - Project configuration and dependencies
- `uv.lock` - Lock file for reproducible builds
- `docs/` - Documentation including feature specifications and deployment guides
  - `reports/` - Centralized location for all project reports and analysis
- `test_*.py` - Test files including integration and unit tests
- `images/` - Project assets

## Development Patterns

### MCP Server Integration
The project uses the Polygon.io MCP server via `uvx` for real-time financial data access. The `create_polygon_mcp_server()` function in `market_parser_demo.py:16` handles server initialization and connection management.

### State Management (GUI)
The `stock_data_fsm` module implements a deterministic finite state machine for robust GUI workflow management:
- States are defined in `stock_data_fsm/states.py:12` with `AppState` enum
- Transitions managed by `StateManager` class in `stock_data_fsm/manager.py:25`
- Context data flows through `StateContext` objects for stateful operations

### Agent Configuration
Both CLI and GUI share identical agent setup with:
- Model: `gpt-5-nano` via OpenAI Responses API
- System prompt focused on financial analysis accuracy
- Token cost tracking via `TokenCostTracker` class

### Testing Strategy
- Unit tests for FSM components in `stock_data_fsm/tests/`
- Integration tests: `test_integration.py` and `test_actual_integration.py`
- Module-specific tests: `test_prompt_templates.py`, `test_response_parser.py`

## Future Development

The `docs/FEATURE_SCOPE_STOCK_DATA_GUI.md` contains detailed specifications for planned GUI enhancements including:

- Structured data display components
- Finite State Machine architecture for button-triggered actions
- Technical indicator displays
- Support/resistance level visualization

When implementing new features, refer to existing patterns in the shared agent configuration and cost tracking systems.

## Important Development Notes

- **Environment Setup**: Create `.env` file with required API keys before running applications (see template in Required Environment Variables section)
- **External Dependencies**: The Polygon.io MCP server requires `uvx` to be available in the system PATH
- **Architecture Preservation**: All file modifications during development should preserve the FSM state management patterns
- **Cost Tracking**: Token cost tracking is enabled by default - check `TokenCostTracker` usage when adding new agent interactions
- **Model Configuration**: Default model is `gpt-5-nano` but can be overridden via `OPENAI_MODEL` environment variable
