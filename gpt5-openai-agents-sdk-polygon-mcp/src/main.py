"""CLI financial analyst using OpenAI Agents SDK, GPT-5, and Polygon.io MCP server.

This script launches a stdio MCP server for Polygon.io tools, runs a single
analysis agent with an input guardrail to ensure finance-related prompts, and
renders only the agent's final output. Users can optionally save analyses as
Markdown reports in the `reports/` directory.
"""

import asyncio
import os
import re
from datetime import datetime
from pathlib import Path
from typing import Optional

from agents import (
    Agent,
    AsyncOpenAI,
    GuardrailFunctionOutput,
    InputGuardrail,
    ModelSettings,
    Runner,
    SQLiteSession,
    function_tool,
    trace,
)
from agents.exceptions import InputGuardrailTripwireTriggered
from agents.mcp import MCPServerStdio
from agents.models.openai_responses import OpenAIResponsesModel
from dotenv import load_dotenv

# FastAPI imports
from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from rich.console import Console
from rich.markdown import Markdown

load_dotenv()

console = Console()


# Models
class FinanceOutput(BaseModel):
    """Structured result from the guardrail check."""

    is_about_finance: bool
    reasoning: str


# Import API models and prompt templates system
# Import the existing prompt templates system
import sys

from api_models import (  # Template Management; Chat Analysis; Button Analysis; System Status; Error Handling; Utility
    AnalysisType,
    ButtonAnalysisRequest,
    ButtonAnalysisResponse,
    ChatAnalysisRequest,
    ChatAnalysisResponse,
    GeneratePromptRequest,
    GeneratePromptResponse,
    PromptMode,
    PromptTemplateInfo,
    SystemHealthResponse,
    SystemMetrics,
    SystemStatusResponse,
    TemplateListResponse,
    TickerContextInfo,
)

sys.path.append("/home/1000211866/Github/market-parser-polygon-mcp/src")
from prompt_templates import PromptTemplateManager, PromptType, TickerExtractor


# Legacy models for backward compatibility
class ChatRequest(BaseModel):
    """Request model for chat endpoint."""

    message: str


class ChatResponse(BaseModel):
    """Response model for chat endpoint."""

    response: str
    success: bool = True
    error: Optional[str] = None


@function_tool
async def save_analysis_report(
    content: str, title: Optional[str] = None, category: str = "general"
) -> str:
    """Persist a Markdown report to `reports/<timestamp>_<title>.md`."""
    reports_dir = Path("reports")
    reports_dir.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    title = title or f"analysis_{timestamp}"
    safe_title = re.sub(r"[^\w\s-]", "", title).replace(" ", "_")
    filepath = reports_dir / f"{timestamp}_{safe_title}.md"

    content = f"""# {title}

**Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
**Category:** {category}

---

{content}

---
*Report generated by Market Analysis Agent*
"""

    filepath.write_text(content, encoding="utf-8")
    return f"Report saved: {filepath}"


guardrail_agent = Agent(
    name="Guardrail check",
    instructions="""Classify if the user query is finance-related.
    Include: stocks, ETFs, crypto, forex, market news, fundamentals, economic indicators, ROI calcs, corporate actions.
    Exclude: non-financial topics (cooking, general trivia, unrelated tech).
    Disambiguate: if term (e.g., Apple, Tesla) could be both, check for finance context words (price, market, earnings, shares). If unclear, return non-finance.
    Output: is_about_finance: bool, reasoning: brief why/why not.""",
    output_type=FinanceOutput,
)


async def finance_guardrail(context, agent, input_data):
    """Validate that the prompt is finance-related before running the agent."""
    result = await Runner.run(guardrail_agent, input_data, context=context)
    final_output = result.final_output_as(FinanceOutput)
    return GuardrailFunctionOutput(
        output_info=final_output,
        tripwire_triggered=not final_output.is_about_finance,
    )


def create_polygon_mcp_server():
    """Create a stdio MCP server instance configured with POLYGON_API_KEY."""
    api_key = os.getenv("POLYGON_API_KEY")
    if not api_key:
        raise Exception("POLYGON_API_KEY not set in environment.")
    return MCPServerStdio(
        params={
            "command": "uvx",
            "args": [
                "--from",
                "git+https://github.com/polygon-io/mcp_polygon@v0.4.0",
                "mcp_polygon",
            ],
            "env": {**os.environ, "POLYGON_API_KEY": api_key},
        }
    )


# Output functions
def print_response(result):
    """Simplified response renderer with emoji support."""
    console.print("\n[bold green]✔ Query processed successfully![/bold green]")
    console.print("[bold]Agent Response:[/bold]\n")

    # Extract content
    final_output = getattr(result, "final_output", result)
    final_text = str(final_output)

    # Check if content has markdown-like formatting
    has_markdown = any(tag in final_text for tag in ["#", "*", "`", "-", ">"])

    if has_markdown:
        # Use Markdown rendering for structured content
        console.print(Markdown(final_text))
    else:
        # Use direct printing with Rich markup for better emoji support
        console.print(final_text)

    # Enhanced separator with emoji
    console.print("\n[dim]" + "─" * 50 + "[/dim]\n")


def print_error(error, error_type="Error"):
    """Display errors in a consistent, readable format for the CLI."""
    console.print(f"\n[bold red]!!! {error_type} !!![/bold red]")
    console.print(str(error).strip())
    console.print("------------------\n")


def print_guardrail_error(exception):
    """Explain why a prompt was blocked by the finance guardrail."""
    console.print("\n[bold yellow]⚠ Guardrail Triggered[/bold yellow]")
    console.print("[yellow]This query is not related to finance.[/yellow]")
    if hasattr(exception, "output_info") and exception.output_info:
        console.print(f"[dim]Reasoning: {exception.output_info.reasoning}[/dim]")
    console.print(
        "[dim]Please ask about stock prices, market data, financial analysis, economic indicators, or company financials.[/dim]"
    )
    console.print("------------------\n")


async def process_financial_query(query: str, session: SQLiteSession, server) -> dict:
    """Process a financial query using the agent system.

    Returns:
        dict: {
            'success': bool,
            'response': str,
            'error': str or None,
            'error_type': str or None
        }
    """
    try:
        with trace("Polygon.io Demo"):
            analysis_agent = Agent(
                name="Financial Analysis Agent",
                instructions=(
                    "Financial analysis agent. Steps:\n"
                    "1. Verify finance-related using guardrail\n"
                    "2. Call Polygon tools precisely; pull the minimal required data.\n"
                    "3. Include disclaimers.\n"
                    "4. Offer to save reports if not asked by the user to save a report.\n\n"
                    "FORMATTING REQUIREMENTS:\n"
                    "- ALWAYS start responses with '🎯 KEY TAKEAWAYS' section using numbered bullet points\n"
                    "- Use financial emojis throughout: 📈 (bullish), 📉 (bearish), 💰 (money/profit), 💸 (loss), 🏢 (company), 📊 (data/analysis)\n"
                    "- Structure responses with proper sections and line spacing for readability\n"
                    "- Use emoji bullet points in lists instead of regular bullets\n"
                    "- Indicate market sentiment clearly with 📈 BULLISH or 📉 BEARISH labels where appropriate\n"
                    "- Use sentiment emojis directly in content: 📈 for bullish/positive indicators, 📉 for bearish/negative indicators\n"
                    "- Place emojis at the beginning of relevant bullet points and statements for immediate visual sentiment\n"
                    "- Example format: '📈 Strong growth momentum detected' or '📉 Declining revenue trend observed'\n"
                    "- Use 📊 for neutral analysis, 💰 for profit/gains, 💸 for losses, 🏢 for company info\n"
                    "- End with standard disclaimers in a clearly formatted section\n\n"
                    "RULES:\n"
                    "Double-check math; limit news to ≤3 articles/ticker in date range.\n"
                    "If the user asks to save a report, save it to the reports folder using the save_analysis_report tool.\n"
                    "When using any polygon.io data tools, be mindful of how much data you pull based \n"
                    "on the users input to minimize context being exceeded.\n"
                    "If data unavailable or tool fails, explain gracefully — never fabricate.\n"
                    "TOOLS:\n"
                    "Polygon.io data, save_analysis_report\n"
                    "Disclaimer: Not financial advice. For informational purposes only."
                ),
                mcp_servers=[server],
                tools=[save_analysis_report],
                input_guardrails=[InputGuardrail(guardrail_function=finance_guardrail)],
                model=OpenAIResponsesModel(model="gpt-5-mini", openai_client=AsyncOpenAI()),
                model_settings=ModelSettings(truncation="auto"),
            )
            output = await Runner.run(analysis_agent, query, session=session)
            final_output = getattr(output, "final_output", output)
            return {
                "success": True,
                "response": str(final_output),
                "error": None,
                "error_type": None,
            }
    except InputGuardrailTripwireTriggered as e:
        reasoning = ""
        if hasattr(e, "output_info") and e.output_info:
            reasoning = f" Reasoning: {e.output_info.reasoning}"
        return {
            "success": False,
            "response": "",
            "error": f"This query is not related to finance.{reasoning} Please ask about stock prices, market data, financial analysis, economic indicators, or company financials.",
            "error_type": "guardrail",
        }
    except Exception as e:
        return {"success": False, "response": "", "error": str(e), "error_type": "agent_error"}


# Initialize prompt template system
prompt_manager = PromptTemplateManager()
ticker_extractor = TickerExtractor()

# FastAPI App Setup
app = FastAPI(
    title="Financial Analysis API",
    description="API for financial queries using Polygon.io data and prompt templates",
    version="1.0.0",
)

# Add CORS middleware for React frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # React dev server
        "http://localhost:3001",  # Alternative React port
        "http://127.0.0.1:3000",
        "http://127.0.0.1:3001",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.post("/chat", response_model=ChatResponse)
async def chat_endpoint(request: ChatRequest) -> ChatResponse:
    """Process a financial query and return the response."""
    if not request.message or len(request.message.strip()) < 2:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Query must be at least 2 characters long",
        )

    try:
        # Create session and server for this request
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server()

        async with server:
            result = await process_financial_query(request.message.strip(), session, server)

            if result["success"]:
                return ChatResponse(response=result["response"])
            else:
                if result["error_type"] == "guardrail":
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST, detail=result["error"]
                    )
                
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail=f"Agent error: {result['error']}",
                )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Server error: {str(e)}"
        ) from e


# ====== NEW PROMPT TEMPLATES API ENDPOINTS ======


@app.get("/api/v1/prompts/templates", response_model=TemplateListResponse)
async def get_prompt_templates():
    """List all available prompt templates."""
    try:
        # Convert to response format
        templates = {}
        for template_type in AnalysisType:
            templates[template_type.value] = PromptTemplateInfo(
                template_type=template_type,
                available=True,
                mode=PromptMode.CONVERSATIONAL,
                enhanced_formatting=True,
                description=f"{template_type.value.replace('_', ' ').title()} analysis template",
            )

        return TemplateListResponse(
            mode="conversational_only", templates=templates, total_count=len(templates)
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve templates: {str(e)}",
        ) from e


@app.post("/api/v1/prompts/generate", response_model=GeneratePromptResponse)
async def generate_prompt_endpoint(request: GeneratePromptRequest):
    """Generate a prompt using the specified template and parameters."""
    try:
        # Convert AnalysisType to PromptType
        prompt_type_map = {
            AnalysisType.SNAPSHOT: PromptType.SNAPSHOT,
            AnalysisType.SUPPORT_RESISTANCE: PromptType.SUPPORT_RESISTANCE,
            AnalysisType.TECHNICAL: PromptType.TECHNICAL,
        }

        prompt_type = prompt_type_map[request.template_type]

        # Generate the prompt
        generated_prompt, ticker_context = prompt_manager.generate_prompt(
            prompt_type=prompt_type,
            ticker=request.ticker,
            custom_instructions=request.custom_instructions,
        )

        # Convert ticker context to response format
        ticker_info = TickerContextInfo(
            symbol=ticker_context.symbol,
            company_name=ticker_context.company_name,
            sector=ticker_context.sector,
            last_mentioned=ticker_context.last_mentioned,
            confidence=ticker_context.confidence,
            source=ticker_context.source,
        )

        return GeneratePromptResponse(
            prompt=generated_prompt,
            ticker_context=ticker_info,
            template_type=request.template_type,
            mode=request.mode,
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate prompt: {str(e)}",
        ) from e


# ====== BUTTON ANALYSIS ENDPOINTS ======


@app.post("/api/v1/analysis/snapshot", response_model=ButtonAnalysisResponse)
async def get_stock_snapshot(request: ButtonAnalysisRequest):
    """Get stock snapshot analysis for button-triggered requests."""
    try:
        # Process through the agent system
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server()

        query = f"Provide a comprehensive stock snapshot analysis for {request.ticker}. Include current price, volume, OHLC data, and recent performance metrics with clear explanations."

        async with server:
            result = await process_financial_query(query, session, server)

            if result["success"]:
                return ButtonAnalysisResponse(
                    analysis=result["response"],
                    ticker=request.ticker,
                    analysis_type=AnalysisType.SNAPSHOT,
                    success=True,
                )
            
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Snapshot analysis failed: {result['error']}",
            )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Snapshot analysis error: {str(e)}",
        ) from e


@app.post("/api/v1/analysis/support-resistance", response_model=ButtonAnalysisResponse)
async def get_support_resistance(request: ButtonAnalysisRequest):
    """Get support and resistance levels analysis for button-triggered requests."""
    try:
        # Process through the agent system
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server()

        query = f"Analyze key support and resistance levels for {request.ticker}. Identify 3 support levels and 3 resistance levels with explanations of their significance for trading decisions."

        async with server:
            result = await process_financial_query(query, session, server)

            if result["success"]:
                return ButtonAnalysisResponse(
                    analysis=result["response"],
                    ticker=request.ticker,
                    analysis_type=AnalysisType.SUPPORT_RESISTANCE,
                    success=True,
                )
            
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Support/Resistance analysis failed: {result['error']}",
            )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Support/Resistance analysis error: {str(e)}",
        ) from e


@app.post("/api/v1/analysis/technical", response_model=ButtonAnalysisResponse)
async def get_technical_analysis(request: ButtonAnalysisRequest):
    """Get technical analysis for button-triggered requests."""
    try:
        # Process through the agent system
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server()

        query = f"Provide comprehensive technical analysis for {request.ticker} using key indicators including RSI, MACD, and moving averages. Explain momentum and trend direction with trading recommendations."

        async with server:
            result = await process_financial_query(query, session, server)

            if result["success"]:
                return ButtonAnalysisResponse(
                    analysis=result["response"],
                    ticker=request.ticker,
                    analysis_type=AnalysisType.TECHNICAL,
                    success=True,
                )
            
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Technical analysis failed: {result['error']}",
            )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Technical analysis error: {str(e)}",
        ) from e


# ====== ENHANCED CHAT ANALYSIS ======


@app.post("/api/v1/analysis/chat", response_model=ChatAnalysisResponse)
async def process_chat_analysis(request: ChatAnalysisRequest):
    """Process a chat message with financial analysis using the agent system."""
    try:
        # Detect analysis type if not provided
        analysis_type = request.analysis_type
        if analysis_type is None:
            detected_type = prompt_manager.detect_analysis_type(request.message)
            if detected_type:
                analysis_type_map = {
                    PromptType.SNAPSHOT: AnalysisType.SNAPSHOT,
                    PromptType.SUPPORT_RESISTANCE: AnalysisType.SUPPORT_RESISTANCE,
                    PromptType.TECHNICAL: AnalysisType.TECHNICAL,
                }
                analysis_type = analysis_type_map.get(detected_type)

        # Convert chat history to the format expected by the system
        chat_history = None
        if request.chat_history:
            chat_history = [
                {"content": msg.content, "role": msg.role} for msg in request.chat_history
            ]

        # Use the existing financial query processing
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server()

        async with server:
            result = await process_financial_query(request.message.strip(), session, server)

            if result["success"]:
                # Extract ticker if possible
                ticker_context = ticker_extractor.extract_ticker(request.message, chat_history)

                return ChatAnalysisResponse(
                    response=result["response"],
                    analysis_type=analysis_type,
                    ticker_detected=(
                        ticker_context.symbol if ticker_context.symbol != "[TICKER]" else None
                    ),
                    confidence=ticker_context.confidence,
                    follow_up_questions=(
                        [
                            f"Would you like a detailed technical analysis for {ticker_context.symbol}?",
                            f"Should we examine support and resistance levels for {ticker_context.symbol}?",
                            "Would you like to analyze a different stock?",
                        ]
                        if ticker_context.symbol != "[TICKER]"
                        else [
                            "Which stock would you like to analyze?",
                            "Would you like a market snapshot or technical analysis?",
                        ]
                    ),
                    success=True,
                )
            else:
                if result["error_type"] == "guardrail":
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST, detail=result["error"]
                    )
                
                raise HTTPException(
                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                    detail=f"Analysis failed: {result['error']}",
                )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Chat analysis failed: {str(e)}",
        ) from e


# ====== SYSTEM STATUS ENDPOINTS ======


@app.get("/api/v1/system/status", response_model=SystemStatusResponse)
async def get_system_status():
    """Get detailed system status and metrics."""
    try:
        metrics = SystemMetrics(
            api_version="1.0.0",
            prompt_templates_loaded=len(PromptType),
            supported_analysis_types=list(AnalysisType),
        )

        return SystemStatusResponse(status="operational", metrics=metrics)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to retrieve system status: {str(e)}",
        ) from e


@app.get("/health", response_model=SystemHealthResponse)
@app.get("/api/v1/health", response_model=SystemHealthResponse)
async def health_check():
    """Health check endpoint."""
    return SystemHealthResponse(
        status="healthy", message="Financial Analysis API is running", version="1.0.0"
    )


# Main CLI
async def cli_async():
    """Run the interactive CLI loop."""
    print("Welcome to the GPT-5 powered Market Analysis Agent. Type 'exit' to quit.")

    try:
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server()

        async with server:
            while True:
                try:
                    user_input = input("> ").strip()
                    if user_input.lower() == "exit":
                        print("Goodbye!")
                        break

                    if not user_input or len(user_input.strip()) < 2:
                        print("Please enter a valid query (at least 2 characters).")
                        continue

                    # Use the shared processing function
                    result = await process_financial_query(user_input, session, server)
                    print("\r", end="")

                    if result["success"]:
                        # Create a mock output object for print_response compatibility
                        class MockOutput:
                            """Mock output object for print_response compatibility."""
                            def __init__(self, response):
                                self.final_output = response

                        print_response(MockOutput(result["response"]))
                    else:
                        if result["error_type"] == "guardrail":
                            # Create a mock exception for print_guardrail_error compatibility
                            class MockException:
                                """Mock exception for print_guardrail_error compatibility."""
                                def __init__(self, error_msg):
                                    # Extract reasoning if present
                                    if " Reasoning: " in error_msg:
                                        reasoning = error_msg.split(" Reasoning: ", 1)[1].split(
                                            " Please ask about", 1
                                        )[0]

                                        class OutputInfo:
                                            """Mock output info for error reasoning."""
                                            def __init__(self, reasoning):
                                                self.reasoning = reasoning

                                        self.output_info = OutputInfo(reasoning)
                                    else:
                                        self.output_info = None

                            print_guardrail_error(MockException(result["error"]))
                        else:
                            print_error(result["error"], "Agent Error")

                except (EOFError, KeyboardInterrupt):
                    print("\nGoodbye!")
                    break
                except Exception as e:
                    print_error(e, "Unexpected Error")

    except Exception as e:
        print_error(e, "Setup Error")
    finally:
        print("Market Analysis Agent shutdown complete")


if __name__ == "__main__":
    asyncio.run(cli_async())
