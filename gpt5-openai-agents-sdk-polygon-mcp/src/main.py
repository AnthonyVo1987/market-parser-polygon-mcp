"""CLI financial analyst using OpenAI Agents SDK, GPT-5, and Polygon.io MCP server.

This script launches a stdio MCP server for Polygon.io tools, runs a single
analysis agent with an input guardrail to ensure finance-related prompts, and
renders only the agent's final output. Users can optionally save analyses as
Markdown reports in the `reports/` directory.
"""

import asyncio
import os
import re
from datetime import datetime
from pathlib import Path
from typing import Optional

from agents import (
    Agent,
    AsyncOpenAI,
    GuardrailFunctionOutput,
    InputGuardrail,
    ModelSettings,
    Runner,
    SQLiteSession,
    function_tool,
    trace,
)
from agents.exceptions import InputGuardrailTripwireTriggered
from agents.mcp import MCPServerStdio
from agents.models.openai_responses import OpenAIResponsesModel
from dotenv import load_dotenv

# FastAPI imports
from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from rich.console import Console
from rich.markdown import Markdown

load_dotenv()

console = Console()


# Models
class FinanceOutput(BaseModel):
    """Structured result from the guardrail check."""

    is_about_finance: bool
    reasoning: str


# FastAPI Models
class ChatRequest(BaseModel):
    """Request model for chat endpoint."""

    message: str


class ChatResponse(BaseModel):
    """Response model for chat endpoint."""

    response: str
    success: bool = True
    error: Optional[str] = None


@function_tool
async def save_analysis_report(content: str, title: Optional[str] = None, category: str = "general") -> str:
    """Persist a Markdown report to `reports/<timestamp>_<title>.md`."""
    reports_dir = Path("reports")
    reports_dir.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    title = title or f"analysis_{timestamp}"
    safe_title = re.sub(r"[^\w\s-]", "", title).replace(" ", "_")
    filepath = reports_dir / f"{timestamp}_{safe_title}.md"

    content = f"""# {title}

**Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
**Category:** {category}

---

{content}

---
*Report generated by Market Analysis Agent*
"""

    filepath.write_text(content, encoding="utf-8")
    return f"Report saved: {filepath}"


guardrail_agent = Agent(
    name="Guardrail check",
    instructions="""Classify if the user query is finance-related.
    Include: stocks, ETFs, crypto, forex, market news, fundamentals, economic indicators, ROI calcs, corporate actions.
    Exclude: non-financial topics (cooking, general trivia, unrelated tech).
    Disambiguate: if term (e.g., Apple, Tesla) could be both, check for finance context words (price, market, earnings, shares). If unclear, return non-finance.
    Output: is_about_finance: bool, reasoning: brief why/why not.""",
    output_type=FinanceOutput,
)


async def finance_guardrail(context, agent, input_data):
    """Validate that the prompt is finance-related before running the agent."""
    result = await Runner.run(guardrail_agent, input_data, context=context)
    final_output = result.final_output_as(FinanceOutput)
    return GuardrailFunctionOutput(
        output_info=final_output,
        tripwire_triggered=not final_output.is_about_finance,
    )


def create_polygon_mcp_server():
    """Create a stdio MCP server instance configured with POLYGON_API_KEY."""
    api_key = os.getenv("POLYGON_API_KEY")
    if not api_key:
        raise Exception("POLYGON_API_KEY not set in environment.")
    return MCPServerStdio(
        params={
            "command": "uvx",
            "args": [
                "--from",
                "git+https://github.com/polygon-io/mcp_polygon@v0.4.0",
                "mcp_polygon",
            ],
            "env": {**os.environ, "POLYGON_API_KEY": api_key},
        }
    )


# Output functions
def print_response(result):
    """Enhanced response renderer with color coding and emoji support."""
    console.print("\n[bold green]âœ” Query processed successfully![/bold green]")
    console.print("[bold]Agent Response:[/bold]\n")

    # Extract and analyze content
    final_output = getattr(result, "final_output", result)
    final_text = str(final_output)

    # Define sentiment keywords for color coding
    bullish_keywords = [
        "bullish",
        "buy",
        "growth",
        "profit",
        "gain",
        "up",
        "positive",
        "strong",
        "ðŸ“ˆ",
        "increase",
        "rising",
        "upward",
        "bullish signals",
        "outperform",
        "buy signal",
        "momentum",
        "rally",
    ]

    bearish_keywords = [
        "bearish",
        "sell",
        "decline",
        "loss",
        "down",
        "negative",
        "weak",
        "ðŸ“‰",
        "decrease",
        "falling",
        "downward",
        "bearish signals",
        "underperform",
        "sell signal",
        "correction",
        "crash",
    ]

    # Split content into lines for processing
    lines = final_text.split("\n")
    processed_lines = []

    for line in lines:
        line_lower = line.lower()

        # Check for bullish sentiment in the line
        bullish_found = any(keyword in line_lower for keyword in bullish_keywords)
        bearish_found = any(keyword in line_lower for keyword in bearish_keywords)

        if bullish_found and not bearish_found:
            # Apply green styling to bullish content
            if "ðŸ“ˆ" in line or "bullish" in line_lower:
                processed_lines.append(f"[bold green]{line}[/bold green]")
            else:
                processed_lines.append(f"[green]{line}[/green]")
        elif bearish_found and not bullish_found:
            # Apply red styling to bearish content
            if "ðŸ“‰" in line or "bearish" in line_lower:
                processed_lines.append(f"[bold red]{line}[/bold red]")
            else:
                processed_lines.append(f"[red]{line}[/red]")
        elif "ðŸŽ¯ KEY TAKEAWAYS" in line:
            # Special styling for key takeaways header
            processed_lines.append(f"[bold cyan]{line}[/bold cyan]")
        elif "ðŸ“Š" in line or "ANALYSIS" in line.upper():
            # Special styling for analysis sections
            processed_lines.append(f"[bold blue]{line}[/bold blue]")
        elif "âš " in line or "DISCLAIMER" in line.upper():
            # Special styling for disclaimers
            processed_lines.append(f"[bold yellow]{line}[/bold yellow]")
        elif line.strip().startswith("ðŸ“ˆ") or line.strip().startswith("ðŸ“‰"):
            # Style individual bullet points with emojis
            if "ðŸ“ˆ" in line:
                processed_lines.append(f"[green]{line}[/green]")
            else:
                processed_lines.append(f"[red]{line}[/red]")
        else:
            # Regular text - keep as is
            processed_lines.append(line)

    # Join processed lines back together
    enhanced_text = "\n".join(processed_lines)

    # Check if content has markdown-like formatting
    has_markdown = any(tag in final_text for tag in ["#", "*", "`", "-", ">"])

    if has_markdown:
        # Use Markdown rendering for structured content
        console.print(Markdown(enhanced_text))
    else:
        # Use direct printing with Rich markup for better emoji and color support
        console.print(enhanced_text)

    # Enhanced separator with emoji
    console.print("\n[dim]" + "â”€" * 50 + "[/dim]\n")


def print_error(error, error_type="Error"):
    """Display errors in a consistent, readable format for the CLI."""
    console.print(f"\n[bold red]!!! {error_type} !!![/bold red]")
    console.print(str(error).strip())
    console.print("------------------\n")


def print_guardrail_error(exception):
    """Explain why a prompt was blocked by the finance guardrail."""
    console.print("\n[bold yellow]âš  Guardrail Triggered[/bold yellow]")
    console.print("[yellow]This query is not related to finance.[/yellow]")
    if hasattr(exception, "output_info") and exception.output_info:
        console.print(f"[dim]Reasoning: {exception.output_info.reasoning}[/dim]")
    console.print(
        "[dim]Please ask about stock prices, market data, financial analysis, economic indicators, or company financials.[/dim]"
    )
    console.print("------------------\n")


async def process_financial_query(query: str, session: SQLiteSession, server) -> dict:
    """Process a financial query using the agent system.

    Returns:
        dict: {
            'success': bool,
            'response': str,
            'error': str or None,
            'error_type': str or None
        }
    """
    try:
        with trace("Polygon.io Demo"):
            analysis_agent = Agent(
                name="Financial Analysis Agent",
                instructions=(
                    "Financial analysis agent. Steps:\n"
                    "1. Verify finance-related using guardrail\n"
                    "2. Call Polygon tools precisely; pull the minimal required data.\n"
                    "3. Include disclaimers.\n"
                    "4. Offer to save reports if not asked by the user to save a report.\n\n"
                    "FORMATTING REQUIREMENTS:\n"
                    "- ALWAYS start responses with 'ðŸŽ¯ KEY TAKEAWAYS' section using numbered bullet points\n"
                    "- Use financial emojis throughout: ðŸ“ˆ (bullish), ðŸ“‰ (bearish), ðŸ’° (money/profit), ðŸ’¸ (loss), ðŸ¢ (company), ðŸ“Š (data/analysis)\n"
                    "- Structure responses with proper sections and line spacing for readability\n"
                    "- Use emoji bullet points in lists instead of regular bullets\n"
                    "- Indicate market sentiment clearly with ðŸ“ˆ BULLISH or ðŸ“‰ BEARISH labels where appropriate\n"
                    "- Include color coding hints: mention 'BULLISH signals' for green coding, 'BEARISH signals' for red coding\n"
                    "- End with standard disclaimers in a clearly formatted section\n\n"
                    "RULES:\n"
                    "Double-check math; limit news to â‰¤3 articles/ticker in date range.\n"
                    "If the user asks to save a report, save it to the reports folder using the save_analysis_report tool.\n"
                    "When using any polygon.io data tools, be mindful of how much data you pull based \n"
                    "on the users input to minimize context being exceeded.\n"
                    "If data unavailable or tool fails, explain gracefully â€” never fabricate.\n"
                    "TOOLS:\n"
                    "Polygon.io data, save_analysis_report\n"
                    "Disclaimer: Not financial advice. For informational purposes only."
                ),
                mcp_servers=[server],
                tools=[save_analysis_report],
                input_guardrails=[InputGuardrail(guardrail_function=finance_guardrail)],
                model=OpenAIResponsesModel(model="gpt-5-mini", openai_client=AsyncOpenAI()),
                model_settings=ModelSettings(truncation="auto"),
            )
            output = await Runner.run(analysis_agent, query, session=session)
            final_output = getattr(output, "final_output", output)
            return {
                "success": True,
                "response": str(final_output),
                "error": None,
                "error_type": None,
            }
    except InputGuardrailTripwireTriggered as e:
        reasoning = ""
        if hasattr(e, "output_info") and e.output_info:
            reasoning = f" Reasoning: {e.output_info.reasoning}"
        return {
            "success": False,
            "response": "",
            "error": f"This query is not related to finance.{reasoning} Please ask about stock prices, market data, financial analysis, economic indicators, or company financials.",
            "error_type": "guardrail",
        }
    except Exception as e:
        return {"success": False, "response": "", "error": str(e), "error_type": "agent_error"}


# FastAPI App Setup
app = FastAPI(
    title="Financial Analysis API", description="API for financial queries using Polygon.io data"
)

# Add CORS middleware for React frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # React dev server
        "http://localhost:3001",  # Alternative React port
        "http://127.0.0.1:3000",
        "http://127.0.0.1:3001",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.post("/chat", response_model=ChatResponse)
async def chat_endpoint(request: ChatRequest) -> ChatResponse:
    """Process a financial query and return the response."""
    if not request.message or len(request.message.strip()) < 2:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Query must be at least 2 characters long",
        )

    try:
        # Create session and server for this request
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server()

        async with server:
            result = await process_financial_query(request.message.strip(), session, server)

            if result["success"]:
                return ChatResponse(response=result["response"])
            else:
                if result["error_type"] == "guardrail":
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST, detail=result["error"]
                    )
                else:
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail=f"Agent error: {result['error']}",
                    )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Server error: {str(e)}"
        )


@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "message": "Financial Analysis API is running"}


# Main CLI
async def cli_async():
    """Run the interactive CLI loop."""
    print("Welcome to the GPT-5 powered Market Analysis Agent. Type 'exit' to quit.")

    try:
        session = SQLiteSession("finance_conversation")
        server = create_polygon_mcp_server()

        async with server:
            while True:
                try:
                    user_input = input("> ").strip()
                    if user_input.lower() == "exit":
                        print("Goodbye!")
                        break

                    if not user_input or len(user_input.strip()) < 2:
                        print("Please enter a valid query (at least 2 characters).")
                        continue

                    # Use the shared processing function
                    result = await process_financial_query(user_input, session, server)
                    print("\r", end="")

                    if result["success"]:
                        # Create a mock output object for print_response compatibility
                        class MockOutput:
                            def __init__(self, response):
                                self.final_output = response

                        print_response(MockOutput(result["response"]))
                    else:
                        if result["error_type"] == "guardrail":
                            # Create a mock exception for print_guardrail_error compatibility
                            class MockException:
                                def __init__(self, error_msg):
                                    # Extract reasoning if present
                                    if " Reasoning: " in error_msg:
                                        reasoning = error_msg.split(" Reasoning: ", 1)[1].split(
                                            " Please ask about", 1
                                        )[0]

                                        class OutputInfo:
                                            def __init__(self, reasoning):
                                                self.reasoning = reasoning

                                        self.output_info = OutputInfo(reasoning)
                                    else:
                                        self.output_info = None

                            print_guardrail_error(MockException(result["error"]))
                        else:
                            print_error(result["error"], "Agent Error")

                except (EOFError, KeyboardInterrupt):
                    print("\nGoodbye!")
                    break
                except Exception as e:
                    print_error(e, "Unexpected Error")

    except Exception as e:
        print_error(e, "Setup Error")
    finally:
        print("Market Analysis Agent shutdown complete")


if __name__ == "__main__":
    asyncio.run(cli_async())
